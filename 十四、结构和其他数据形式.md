通过结构、联合、typedef，C提供了有效处理数据的工具和处理可移植数据的工具。
### 结构体
##### 结构声明、定义结构变量
结构有两层含义：结构布局（告诉编译器如何表示数据，但未分配空间）；结构变量。

- 声明结构：`struct 标记 {...;...;...; };`  描述了一个结构的组织布局（有时也称模板）。
- 定义结构变量：`struct 标记 结构变量;`   `struct 标记`相当于一般声明中的`int`或`float`，即创建了一个名为`struct 标记`的新类型。

声明结构和定义结构变量可合并成一个步骤：`struct {...}结构变量;`
##### 初始化结构、访问结构成员
指定**初始化器designated initializer**，使用**点运算符**（结构成员运算符）和**成员名标识特定的元素**（数组用方括号和下标）即可初始化和访问，各项用逗号隔开。对特定成员的最后一次赋值才是实际获得的值。
访问：`结构变量.成员名`
初始化：`struct 标记 结构变量 = {.成员名1 =val1 , .成员名2 =val2 , ... }；`

```c
struct book {  //结构声明
    char title[MAXTITL];
    char author[MAXAUT];
    float value;
};
struct book library;  /定义一个结构变量library

s_gets(library.author,MAXAUT);  //访问使用了library的第二个成员
struct book library = {.value = 0.99};  //初始化了library的第三个成员
```
### 结构数组
##### 声明结构数组、标识成员
声明：`struct 标记 数组名[value];`声明一个内含value个元素的数组，每个元素都是一个`struct 标记`类型的结构变量。数组名是该数组的地址，即该数组首元素（数组名[0]）的地址。
标识结构数组的成员：`结构变量名.成员名`
![image.png](https://cdn.nlark.com/yuque/0/2022/png/25729887/1668604576719-576ebb18-fb83-41b7-a28e-060d75871387.png#clientId=u3da8a963-948f-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=381&id=uac098e18&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1108&originWidth=1461&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1809336&status=done&style=none&taskId=u37fe1b4a-9ed8-408f-90f2-7b5bfd98cd7&title=&width=502)
```c
struct book {  //结构声明
    char title[MAXTITL];
    char author[MAXAUT];
    float value;
};
//声明一个内含MAXAUT个元素的数组library，每个元素都是一个struct book类型的结构变量
//library是一个数组名，数组元素library[0]、library[1]分别是第1、2个结构变量
//
struct book library[MAXAUT];

library // 一个book结构的数组，library是
library[0]  //一个数组元素，该元素是book结构变量
library[0].title  //一个char数组（library[0]的title成员）
library[0].title[4]  //数组中library[0]元素的title成员的一个字符
```
### 嵌套结构
在一个结构中包含另一个结构。
访问嵌套结构的成员时，要用两次**点运算符**，从左往右解释。
### 指向结构的指针

1. 声明与初始化结构指针：

声明：`struct 标记 * 指针名;`
赋值：`指针名 = &结构变量;`
与数组不同，结构变量名不是结构的地址，故要在结构变量名前加上`&`运算符。

2. 用指针访问成员需使用`->`运算符：

`指针->成员`，表示该指针所指向结构的一个成员。
即：指向结构的指针后面的`->`运算符，结构变量后面的`.`运算符，工作方式相同。
```c
struct guy{
    char job[20];
    float income;
};
struct guy * him;  //初始化
him = &bar; 

// him是指向guy类型结构的bar指针，下面关系恒成立
bar.income == (*him).income == him->income 
```
### 向函数传递结构的信息
##### 传递结构成员
只要结构成员是一个具有单个值的数据类型（如int、double、指针等），便可将其作为参数传递给接受该特定类型的函数。
##### 传递结构的地址
如果需要在被调函数中修改主调函数成员的值，便要传递成员的地址，需使用`&`运算符来获取结构的地址。
##### 传递结构
被调函数会创建原来结构的副本。
##### 其他结构特性

1. 允许将一个结构赋值给另一个结构，但是数组不能这样做。

如`结构变量1 = 结构变量2;`将结构变量2的每个成员的值都赋给结构变量1，即便成员是数组，也能完成赋值

2. 可以将一个结构初始化为相同类型的另一个结构
3. 可以将结构本身作为参数传递，也能将结构作为返回值返回，结构指针也允许这种双向通信
##### 结构和结构指针的选择
传递指针：执行快，但是无法保护数据，但const限定符解决了此问题
传递结构：能保护原始数据，代码风格更清楚，但是传递结构会创建副本，浪费时间和空间
##### 结构中的字符数组和字符指针
若要用结构储存字符串，用字符数组作为成员比较简单。
也可用指向char的指针，但是误用会导致严重的问题。结构变量的指针只用来管理已分配和在别处分配的字符串
```c
#define len 20;
struct name{char first[len];char last[len];}；
struct p_name{char * first; char * last;}；
struct name a = {"abc","efg"};
struct name b = {"abc","efg"};
printf("%s and %s\n",a.first,b.first);
//对于a结构变量，字符串存在结构内部，共分配40字节内存
//对于b结构变量，字符串存在编译器存储常量的地方，结构本身只存储了2个地址，共分配16字节

struct name A；
struct p_name B；
scanf("%s",A.first);
scanf("%s",B.first); //有一个潜在的危险
//scanf读取的字符串放到B.first表示的地址上，这是未经初始化的变量，地址可以是任何值
```
##### 结构、指针、malloc()
使用malloc()分配内存，并使用指针储存该地址，即可在结构中使用指针处理字符串。即字符串未储存在结构中，它们储存在malloc()分配的内存块中，结构中储存着字符串的地址。
##### 复合字面量和结构C99
复合字面量特性可用于结构和数组。复合字面量是提供临时需要的值的一种手段。
将类型名放在圆括号里，后面紧跟一个用花括号括起来的初始化列表。
##### 伸缩型数组成员C99
利用此特性声明的结构，其最后一个数组成员具有一些特性：

- 该数组不会立即存在
- 使用此伸缩型数组成员可以编写合适的代码，就好像它确实存在并具有所需数目的元素一样

声明一个伸缩型数组成员有如下规则：

- 伸缩型数字成员必须是结构的最后一个成员
- 结构中必须至少有一个成员
- 伸缩数组的声明类似于普通数组，但方括号中是空的

带伸缩型数组成员的结构有以下处理要求：

- 不能用结构进行赋值或拷贝，否则只能拷贝除了伸缩型数组成员以外的成员（可用memcpy()函数）
- 不要以按值方式把这种结构传递给结构，要传递结构的地址
- 不要使用带伸缩型数组成员的结构作为 数组成员
##### 匿名结构C11
匿名结构是一个没有名称的结构成员。
##### 使用结构数组的函数

### 把结构内容保存到文件
。。。第十三章
### 链式结构
结构的用途之一：创建新的数据形式，如队列、二叉树、堆、哈希表、图表
许多这样的形式都由**链式结构linked structure**组成：每个结构都包括一些数据项和一两个指向其他同类型结构的指针，这些指针把一个结构和另一个结构**链接**起来，并提供一种路径能**遍历**整个彼此链接的结构。
### 联合简介
**联合union**是一种数据类型，能在同一个内存空间中储存不同的数据类型（非同时储存）。
使用联合类型的数组，其中的联合大小都相等，每个联合可以储存各种类型数据。
##### 声明、初始化、使用
声明：`union 标记 { 成员1 ; 成员2 ; 成员3 ; ...; };`只能存储成员1类型的值**或**成员1类型的值**或.**..
编译器会分配足够的空间以便储存联合声明中占用最大字节的类型。
初始化：1、把一个联合初始化为另一个同类型的联合；2、初始化联合的第一个元素；3、使用指定初始化器
在联合中，一次只存储一个值，用**点运算符**表示正在使用哪种数据类型。
用指针访问联合时要使用`->`运算符。
联合有以下用法：
用一个成员把值储存在一个联合中，然后用另一个成员查看内容
在结构中储存与其成员有从属关系的信息
```c
union hold { //只能储存一个int类型的值，或一个double类型的值，或一个char类型的值
	int digit;
	double bigf;
	char letter;
};

union hold fit;  //hold类型的联合变量
union hold save[10];  //内含10个联合变量的数组
union hold * pu;  //指向hold类型联合变量的指针

union hold valA;
valA.letter = 'R';
union hold valB = valA;  //用另一个联合来初始化
union hold valC = {88};  //初始化联合的第一个成员
union hold valD = { .bigf = 118.0};  //使用指定初始化器

fit.digit = 23; //把23储存在fit
fit.bigf = 2.0;  //清除23，储存2.0
fit.letter = 'h'  //清除2.0，储存h

pu = &fit;
x = pu->digit;  //相当于x=fit.digit
```
##### 匿名联合
匿名联合是一个结构或联合的无联合成员。
##### 结构和联合运算符
**成员运算符**`.`：与结构变量或联合变量一起使用，指定结构变量或联合变量的一个成员。
**间接成员运算符**`->`：与指向结构或联合的指针一起使用，指定结构变量或联合变量的一个成员。
### 枚举类型
##### 声明与使用
**枚举类型enumerated type**声明符号名称来表示整型常量。使用enum关键字，可以创建一个新”类型“并指定它可具有的值。实际上，**enum常量**是int类型，只要能使用int了类型的地方就能使用枚举类型。
声明：`enum 标记 {枚举符1 , 枚举符2 , ...};`
创建：`enum 标记 枚举变量;`
**枚举符enumerator**是int类型常量，是有名称的常量，只要能使用整形常量的地方就可以使用**枚举常量**。（枚举符/enum常量/枚举常量 表示同一个东西）
**枚举变量**可以是任意整数类型，前提是该整数类型可以储存**枚举常量**。
##### 共享名称空间
C语言使用**名称空间namespace**表示程序中的各部分，即通过名称来识别。
作用域是名称空间概念的一部分：两个不同作用域的同名变量不冲突，两个相同作用域的同名变量冲突。
名称空间是分类别的。在特定作用域中的结构标记、联合标记、枚举标记都共享相同的名称空间，该名称空间与普通变量使用的空间不同。即在相同作用域中变量和标记的名称可以相同，但不能在相同作用域中声明两个同名标记或同名变量。
### typedef简介
利用**typedef**可为某一类型自定义名称。**typedef**没有创建任何新类型，只是为某个已存在的类型增加了一个方便使用的标签。typedef中使用的名称遵循变量的命名规则。
与#define的不同：

- typedef创建的符号名只受限于类型，不能用于值
- typedef由编译器解释，不是预处理器
- 在其受限范围内，typedef更灵活

使用typedef的原因：

- 为经常出现的类型创建一个方便、易识别的类型名
- 给复杂的类型命名
```c
//功能一样，都是用BYTE替换unsigned char
#define BYTE unsigned char
typedef unsigned char BYTE;
BYTE x , y[10] , *z ;  //使用BYTE定义变量

typedef char * STRING;  //编译器将STRING解释称一个类型的标识符，该类型是指向char的指针
SRTING name , sign;
//相当于：
char * name, * sign;

#define STRING char *
SRTING name , sign;
//相当于：
char * name, sign;  //只有name才是指针
```
### 其他复杂的声明

### 函数和指针

