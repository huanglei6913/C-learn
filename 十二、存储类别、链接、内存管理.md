### 存储类别storage class
#### 术语概念
**对象object**：数据存储在内存里，每个值都占用一定的物理内存，C把这样一块内存称为对象。
**标识符**可指定特定对象的内容。如`int entity = 3;`标识符entity是C程序指定硬件内存中的对象的方式

##### 作用域scope
作用域描述程序中可访问标识符的区域。
**块block**：是用一对花括号括起来的代码区域。如，整个函数体是一个块，函数中任意复合语句是一个块。
**块作用域block scope**：定义在块中的变量具有块作用域。声明在内层块中的变量，其作用域只限于该声明所在的块。
**函数作用域function scope**：仅用于goto语句的标签。
**函数原型作用域function prototype scope**：用于函数原型中的形参名，范围从形参定义处到原型声明结束。即编译器只关心形参类型，形参名无关紧要。只有变长数组中，形参名才有用。
**文件作用域file scope**：变量的定义在函数外面，具有文件作用域。从定义处到该定义所在文件的末尾均有效。文件作用域变量也称**全局变量global variable**。

##### 链接linkage
**外部链接**：外部链接变量可在多文件程序中使用。
**内部链接：**内部链接变量只能在一个翻译单元中使用。
**无链接**：无链接变量代表私有。
块作用域、函数作用域、函数原型作用域的变量都是无链接变量。
文件作用域可以是外部/内部链接。
外部链接的文件作用域：可延伸至多个翻译单元的作用域，简称”**全局/程序作用域**“
内部链接的文件作用域：仅限于一个翻译单元的作用域，简称”**文件作用域**“

##### 翻译文件translation unit
源代码文件及其包含的头文件，看作一个单独文件，被称为翻译单元。
描述一个具有文件作用域的变量时，其实际可见范围时整个翻译单元。若程序由多个源代码文件组成，则该程序也由多个翻译单元组成。
##### 存储期storage duration
作用域、链接表明程序哪些部分可以使用此标识符，存储期描述了通过这些标识符访问对象的生存期。
**静态存储期**：对象在程序执行期间一直存在。文件作用域自动具有静态存储期。
**线程存储期**：用于并发程序设计，程序执行可被分为多个线程。对象从被声明到线程结束一直存在。
**自动存储期**：块作用域通常具有自动存储期。当程序进入定义变量的块时，为变量分配内存，退出时释放内存。变长数组的存储期从声明处到块的末尾。
**动态分配存储期**： malloc()、free()

#### 5种变量存储类别

![image.png](https://cdn.nlark.com/yuque/0/2022/png/25729887/1667984633180-2f73a77b-52c5-425b-9b8f-8d6f5b2ad2fc.png#clientId=uf55f0ca6-ba58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=229&id=u1a61b848&margin=%5Bobject%20Object%5D&name=image.png&originHeight=343&originWidth=1361&originalType=binary&ratio=1&rotation=0&showTitle=false&size=603991&status=done&style=stroke&taskId=u108faaaf-2600-486e-adab-bac65780c09&title=&width=907.3333333333334)
##### 自动变量
默认情况下，声明在块或函数头中的变量都属于自动存储类别，可显式使用关键字**auto**（存储类别说明符storage-class specifier）
块中声明的变量仅限于该块及其包含的块使用。
若内层块中声明的变量，与外层块的变量同名，内层块会**隐藏**外层块的含义。离开内层块后，外层块变量的作用域又回到原来的作用域。
循环体是整个循环块的子块，即使不使用花括号也是一个块。
自动变量不会初始化，除非显式初始化它。
##### 寄存器变量
寄存器变量存储在寄存器中，无法获取寄存器变量的地址。
使用关键字**register**可声明寄存器变量，请求编译器分配寄存器存储变量，若失败，寄存器变量变为普通的自动变量。即便失败也不能对该变量使用地址运算符。
##### 外部链接的静态变量
也称**外部存储类别external storage class**、**外部变量external variable**，把变量的定义性声明放在所有函数外面便创建了外部变量。
定义式声明defining declaration不能使用extern，引用式声明referencing declaration必须使用**extern**（若在函数中要再次声明此外部变量，须用**extern**声明，但此声明可选；若一个源代码文件使用的外部变量定义在另一个源代码文件中，必须用**extern**在该文件中声明）
块作用域中的变量将**隐藏**文件作用域中的同名变量，可在局部变量声明中加auto表明区分。
若未显式初始化外部变量，它们会被初始化为0，但只能用常量表达式初始化文件作用域变量。外部变量只能初始化一次，必须在定义该变量时进行。
```c
//外部变量a、b在程序中一直存在不受限于任何函数
int a;  //对main()、magic()均不可见，但对文件中未创建局部a变量的其他函数可见
int magic();
int main(void)
{
    int a;  //默认为自动变量，属于main()私有
}
int b; //对magic()可见，对main()不可见，因为b声明在main()后面
int magic()
{
    auto int a; //声明为自动变量，属于magic()私有
}
```
##### 内部链接的静态变量
在所有函数外部用**static**定义，过去称为外部静态变量（但是矛盾，因为是内部链接）
可用extern在函数中重复声明任何具有文件作用域的变量，不会改变链接属性。
##### 块作用域的静态变量
在块中（提供块作用域和无链接）用**static**声明，也叫**局部静态变量**、**内部静态存储类别internal static storage class**。
若未显式初始化静态变量，它们会被初始化为0

#### 存储类别说明符
**auto**：自动存储期，用于块作用域的变量声明
**register**：用于块作用域的变量，保护了变量的地址不被获取
**static**：静态存储期
**extern**：表明声明的变量在别处
**_Thread_local**：
**typedef**：

![image.png](https://cdn.nlark.com/yuque/0/2022/png/25729887/1668069038906-16246427-e2cc-4e85-b3ff-0a430ef9ba5d.png#clientId=uf55f0ca6-ba58-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=533&id=u5b2864a0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=799&originWidth=1448&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1752958&status=done&style=stroke&taskId=u495c7bd8-d7e9-4af9-b5f2-851b83932ca&title=&width=965.3333333333334)

##### 存储类别和函数
函数也有存储类别：**外部函数**（默认）可以被其他文件的函数访问、**静态函数**只能用于其定义所在的文件、**内联函数**
用**static**创建的函数属于特定模块私有，用**extern**声明定义在其他文件的函数。无关键字默认是外部函数。
##### 存储类别的选择
随意使用外部存储类别的变量导致的后果，远超于其带来的便利。const数据除外。
保护性程序设计的法则：**按需知道**原则。尽量在函数内部解决函数的任务，只共享需要共享的变量。

### 分配内存
##### malloc(字节数)
函数返回一个通用指针，即指向void的指针。使用强制类型转换去匹配类型。
若分配内存失败，则返回空指针（NULL）。可调用exit()结束程序：返回值EXIT_SUCCESS表示普通的程序结束，返回值EXIT_FAILURE表示程序异常中止。
##### calloc(存储单元数量，存储单元大小)
函数返回一个通用指针，即指向void的指针。使用强制类型转换去匹配类型。
接受两个无符号整数作为参数（ANSI规定为size_t类型）
函数将块中所有位都设置为0
##### free(地址)
不能释放通过其他方式分配的内存，比如声明一个数组。
动态分配的内存数量只会增加，除非用free()释放。利用macclo()创建的指针若是自动变量，当调用函数结束时，指针随即被销毁便无法再访问此处内存，若未释放此块内存，可能会造成**内存泄漏memory leak**。
##### 变长数组
目前我们有3种创建数组的方法：

1. 声明数组时，用常量表达式表示数组的维度，用数组名访问数组元素。可用静态内存/自动内存创建。
2. 声明变长数组时，用变量表达式表示数组的维度，用数组名访问数组元素。只能用自动内存创建。
3. 声明一个指针，用malloc()，将其返回值赋给指针，使用指针访问数组元素。该指针是静态/自动的。

变长数组与malloc()创建数组的不同：
变长数组是自动存储类型；用malloc()创建的数组不必局限在一个函数内访问；对于多维数组，变长数组更方便。
##### 存储类别和动态内存分配
理想化模型的内存分为3部分：

1. 一部分供具有外部链接、内部链接、无链接的静态变量使用。静态存储类别所用的内存数量在编译时确定，随程序而创建销毁。
2. 一部分供自动变量使用。这部分内存通常作为**栈stack**来处理，即新创建的变量按顺序加入内存，然后以相反的顺序销毁。
3. 一部分供动态内存使用。内存块可以在一个函数中创建，在另一个函数中销毁，未使用的内存块分散在已使用的内存块之间。使用动态内存通常比使用栈内存慢。
### 类型限定符
##### const类型限定符
const放在*左侧任意位置，限定了指针指向的数据不能改变；const放在*右侧，限定了指针本身不能改变。
声明为函数形参的指针时，若指针只用与给函数访问值，应将其声明为一个指向const限定类型的指针。
在文件间共享const数据可用这两个策略：

1. 遵循外部变量的常用规则，即在一个文件中使用定义式声明，在其他文件中使用引用式声明（extern关键字）
2. 将const变量放在一个头文件中，然后在其他文件中包含该头文件。这种方案须在头文件中用关键字static声明全局const变量（具有内部链接属性），相当于给每个文件提供了一个单独的数据副本，缺点是，数据是重复的，可能导致数据量庞大。
##### volatile类型限定符
volatile告诉计算机，**代理**（而不是变量所在的程序）可以改变该变量的值。通常被用于硬件地址及在其他程序或同时运行的线程中共享数据。
volatile涉及编译器的优化：
```c
val1 = x;
/* 一些不使用x的代码 */
/* 其他代理可能会在中间改变x的值 */
val2 = x;
```
进行优化的编译器可能会注意到以上代码使用了两次x，但未改变其值。故编译器将x的值临时储存在寄存器中，在val2需要使用x时，从寄存器直接读取x的值，以节约时间。此过程被称为**高速缓存caching**。但若其他一些代理在以上两条语句之间改变了x的值，就不能如此优化。若没有volatile编译器就不知道此类情况会发生，为了安全编译器不会惊醒高速缓存（以前的情况）。现在如果声明中没有volatile关键字，编译器会假定变量的值在使用过程中不变。
可以同时用cons和volatile限定一个值，如用const将硬件时钟设置为程序不能更改的变量，但用volatile可以通过代理改变，只能在声明中同时使用这两个限定符。
##### restrict类型限定符
restrict允许编译器优化某部分代码以更好的支持计算。只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。
在本例中，若未使用restrict，编译器须假设最坏的情况（在两次使用指针之间，其他标识符可能改变了数据）；若使用了restrict，编译器就可以选择捷径优化计算：
```c
int ar[10];
//restar是访问由malloc()所分配内存的唯一且初始的方式
int * restrict restar = (int *)malloc(10*sizeof(int));
//指针par既不是访问ar数组中数据的初始方式，也不是唯一方式
int * par = ar;
for(n=0;n<10;n++)
{
    par[n] += 5;
    restar[n] += 5;
    ar[n] *= 2; //ar改变了par的数据
    par[n] += 3;
    restar[n] += 3;
}
/* 涉及到restar的两条语句可以用 restar[n] += 8;替换。 */
/* 但是如果把par的两条语句用 par[n] += 8;替换，将导致计算出错。
    因为for循环在给par两次访问相同的数据之间，用ar改变了该数据的值。 */
```
restrict还可以用于函数形参中的指针，即编译器假定在函数体内其他标识符不会修改该指针指向的数据。
```c
//这两个函数都从位置s2把n字节拷贝到位置s1，memcpy()要求两个位置不重叠，memmove()无此要求

//memcpy()声明s1 s2为restrict说明两个指针都是访问相应数据的唯一方式，故它们不能访问相同块的数据
void * memcpy(void * restrict s1 , const void * restrict s2 , size_t n);
//memmove()允许重叠，故在拷贝数据时不得不更加小心，以防在使用数据前就覆盖了数据
void * memmove(void * s1 , const void * s2 , size_t n);

```
##### _Atomic类型限定符

##### 旧关键字的新位置
C99允许将**类型限定符**和**存储类别说明符static**放在函数原型和函数头的形式参数的初始方括号中。
